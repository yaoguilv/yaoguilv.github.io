<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=b294cd46a7d22caee322ecfce0d773379153c86a">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>passing arrays | yaoguilv.github.io</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="passing arrays" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/CppArrays.html" />
<meta property="og:url" content="http://localhost:4000/CppArrays.html" />
<meta property="og:site_name" content="yaoguilv.github.io" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/CppArrays.html","headline":"passing arrays","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <h1>yaoguilv.github.io</h1>
        <h2></h2>

        <section id="downloads">
          
          <a href="http://github.com/yaoguilv/yaoguilv.github.io" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h2 id="passing-arrays">passing arrays</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;list&gt;

// Method 1: works but very little security.  It is impossible to validate
// the inputs since the size of data still cannot be validated. If length is too large
// undefined behavior will occur.
void printArray(int data[], int length)
{
    for(int i(0); i &lt; length; ++i)
    {
        std::cout &lt;&lt; data[i] &lt;&lt; ' ';
    }
    std::cout &lt;&lt; std::endl;
}

// Method 2: Type safe and more generic.  Works with any container that supports forward iterators.
// Limitation - cannot validate iterators so caller could pass null or invalid pointers.  Typesafe - won't
// allow you to pass inconsistent iterator types.  Allows you to pass any valid range of a container.
template &lt;class ForwardIteratorType&gt; 
void printArray(ForwardIteratorType begin, ForwardIteratorType end)
{
    while(begin != end)
    {
        std::cout &lt;&lt; *begin &lt;&lt; ' ';
        ++begin;
    }
    std::cout &lt;&lt; std::endl;
}

// Method 3 - This implementation is as typesafe and secure as you can get but
// does not allow a subrange since the entire container is expected.  It could
// be useful if you want that extra security and know that you want to operate
// on the entire container.
template &lt;class ContainerType&gt; 
void printArray(const ContainerType&amp; container)
{
    ContainerType::const_iterator current(container.begin()), end(container.end());
    for( ; 
        current != end; 
        ++current)
    {
        std::cout &lt;&lt; *current &lt;&lt; ' ';
    }
    std::cout &lt;&lt; std::endl;
}

int main()
{
    // Method 1.
    const int LENGTH(6);
    int data[LENGTH] = { 5, 7, 8, 9, 1, 2 };
    printArray(data, LENGTH);

    // Method 2.
    printArray(data, data + LENGTH);
    std::vector&lt;int&gt; vData(data, data + LENGTH);
    printArray(vData.begin(), vData.end());
    std::list&lt;int&gt; lData(data, data + LENGTH);
    printArray(lData.begin(), lData.end());
    std::deque&lt;int&gt; dData(data, data + LENGTH);
    printArray(dData.begin(), dData.end());
    // won't compile if caller accidentally mixes iterator types.
    //printArray(dData.begin(), vData.end());

    // method 3.
    printArray(vData);
    printArray(dData);
    printArray(lData);
	return 0;
}
</code></pre></div></div>

<h2 id="returning-arrays-from-functions">Returning arrays from functions</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;

// Prints out array elements. Method 2 from PART I.
template &lt;class ForwardIteratorType&gt; 
void printArray(ForwardIteratorType begin, ForwardIteratorType end)
{
    while(begin != end)
    {
        std::cout &lt;&lt; *begin &lt;&lt; ' ';
        ++begin;
    }
    std::cout &lt;&lt; std::endl;
}

// The caller must decide whether to pass an empty container.  This function will 
// add to it.  
void readScores(std::vector&lt;int&gt;&amp; container)
{
    std::cout &lt;&lt; "Type the list of scores followed by a non-numeric character and press enter when finished. " 
              &lt;&lt; "For instance (22 25 26 f &lt;enter&gt; " &lt;&lt; std::endl;
    int temp(0);
    while(std::cin &gt;&gt; temp)
    {
        container.push_back(temp);
    }
    // clear and discard any leftover data from the input stream.
    std::cin.clear();
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
}

int main()
{
    std::vector&lt;int&gt; scores; // uninitialized.  Let readScores fill it.
    readScores(scores);
    printArray(scores.begin(), scores.end());
    return 0;
}
</code></pre></div></div>

      </section>
    </div>

    
  </body>
</html>
